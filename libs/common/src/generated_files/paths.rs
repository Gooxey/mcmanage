//! This module provides various statics describing the paths to specific files generated by the MCManage applications.

use std::{
    env::current_exe,
    fs::create_dir_all,
    path::{
        Component,
        Path,
        PathBuf,
    }, sync::Once
};
use once_cell::sync::Lazy;

use goolog::fatal;
use tokio::fs;

use super::default_files::get_example_content;

const GOOLOG_CALLER: &str = "InitPaths";
/// A static to ensure the paths get initialized only once.
static INIT: Once = Once::new();

/// The path to the executable at `./` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static ROOT_DIR: Lazy<PathBuf> = Lazy::new(|| {
    /// This function will get the workspace's root path.
    fn get_workspace_root() -> PathBuf {
        let root_dir = std::process::Command::new(env!("CARGO"))
            .arg("locate-project")
            .arg("--workspace")
            .arg("--message-format=plain")
            .output()
            .unwrap_or_else(|error| {
                fatal!("Failed to run the cargo command to get the path to the workspace's root directory. Error: {error}")
            })
            .stdout;
        PathBuf::from(
            std::str::from_utf8(&root_dir)
            .unwrap_or_else(|error| {
                fatal!("The `root_dir` generated by cargo should be convertible to a string. Error: {error}")
            })
            .trim()
        )
            .parent()
            .unwrap_or_else(|| {
                fatal!("Failed to create the path to the testing directory.")
            })
            .to_path_buf()
    }


    if cfg!(test) {
        let root_dir = get_workspace_root().join("testing_files");
        create_dir_all(root_dir.clone()).unwrap_or_else(|error| fatal!("Failed to create the testing directory at '{}'. Error: {error}", root_dir.display()));

        root_dir
    } else {
        let root_dir = current_exe()
            .unwrap_or_else(|error| fatal!("Could not get the path to the executable. Error: {error}"))
            .join("..");
        let mut root_dir = dunce::canonicalize(root_dir)
            .unwrap_or_else(|error| fatal!("Failed to canonicalize the ROOT_DIR path. Error: {error}"));

        // this will prevent the root dir getting set to './target/debug' during development
        for directory in root_dir.components() {
            if directory == Component::Normal("target".as_ref()) {
                root_dir = get_workspace_root();
                break;
            }
        }

        root_dir
    }
});
/// The directory for all databases. \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static DATA_DIR: Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));

/// The path to the config directory at `./config` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static CONFIG_DIR:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));
/// The path to the config directory at `./config/config.toml` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static CONFIG_FILE:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));
/// The path to the config directory at `./config/server_list.toml` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static SERVER_LIST_FILE:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));
/// The path to the config directory at `./config/server_types.toml` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static MCSERVER_TYPES_FILE:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));

/// The path to the logs directory at `./logs` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static LOGS_DIR:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));
/// The path to the server logs directory at `./logs/servers` \
/// This directory is intended for log files from Minecraft servers. \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static SERVER_LOGS_DIR:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));
/// The path to the log file at `./logs/mcmanage.log` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static LOG_FILE:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));

/// The path to the share directory at `./share` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static SHARE_DIR:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));
/// The path to the frontend directory at `./share/frontend` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static FRONTEND_DIR:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));

/// The path to the servers directory at `./servers` \
/// \
/// **Note:** If not initialized by the [`init_paths`] function, the PathBuf will be empty.
pub static SERVERS_DIR:  Lazy<PathBuf> = Lazy::new(|| ROOT_DIR.join("data"));

// pub fn init_paths() {
//     fn root_dir() -> PathBuf {
//         /// This function will get the workspace's root path.
//         fn get_workspace_root() -> PathBuf {
//             let root_dir = std::process::Command::new(env!("CARGO"))
//                 .arg("locate-project")
//                 .arg("--workspace")
//                 .arg("--message-format=plain")
//                 .output()
//                 .unwrap_or_else(|error| {
//                     fatal!("Failed to run the cargo command to get the path to the workspace's root directory. Error: {error}")
//                 })
//                 .stdout;
//             PathBuf::from(
//                 std::str::from_utf8(&root_dir)
//                 .unwrap_or_else(|error| {
//                     fatal!("The `root_dir` generated by cargo should be convertible to a string. Error: {error}")
//                 })
//                 .trim()
//             )
//                 .parent()
//                 .unwrap_or_else(|| {
//                     fatal!("Failed to create the path to the testing directory.")
//                 })
//                 .to_path_buf()
//         }


//         if cfg!(test) {
//             let root_dir = get_workspace_root().join("testing_files");
//             create_dir_all(root_dir.clone()).unwrap_or_else(|error| fatal!("Failed to create the testing directory at '{}'. Error: {error}", root_dir.display()));

//             root_dir
//         } else {
//             let root_dir = current_exe()
//                 .unwrap_or_else(|error| fatal!("Could not get the path to the executable. Error: {error}"))
//                 .join("..");
//             let mut root_dir = dunce::canonicalize(root_dir)
//                 .unwrap_or_else(|error| fatal!("Failed to canonicalize the ROOT_DIR path. Error: {error}"));

//             // this will prevent the root dir getting set to './target/debug' during development
//             for directory in root_dir.components() {
//                 if directory == Component::Normal("target".as_ref()) {
//                     root_dir = get_workspace_root();
//                     break;
//                 }
//             }

//             root_dir
//         }
//     }

//     INIT.call_once(|| {
//         ROOT_DIR = root_dir();
//         DATA_DIR = ROOT_DIR.join("data");
//         SERVERS_DIR = ROOT_DIR.join("servers");

//         CONFIG_DIR = ROOT_DIR.join("config");
//         CONFIG_FILE = CONFIG_DIR.join("config.toml");
//         SERVER_LIST_FILE = CONFIG_DIR.join("server_list.toml");
//         MCSERVER_TYPES_FILE = CONFIG_DIR.join("server_types.toml");

//         LOGS_DIR = ROOT_DIR.join("logs");
//         SERVER_LOGS_DIR = LOGS_DIR.join("servers");
//         LOG_FILE = LOGS_DIR.join("mcmanage.log");

//         SHARE_DIR = ROOT_DIR.join("share");
//         FRONTEND_DIR = SHARE_DIR.join("frontend");
//     })
// }

/// This function will generate the [`struct@CONFIG_DIR`] if it does not exist and return a [`PathBuf`] pointing to a non-existing file located at:
///     1. '[`struct@CONFIG_DIR`]/invalid_`{file_name}`.toml', in case no other invalid file could be found.
///     2. '[`struct@CONFIG_DIR`]/invalid_`{file_name}`(`{counter starting at 1}`).toml', in case other invalid files could be found.
///
/// Note: `file_name` would be, for instance, for the static [`struct@SERVER_LIST_FILE`], `server_list`. \
/// \
/// # Panics
///
/// This function will panic in case the given static's file should not be renamed to an 'invalid file'.
pub async fn get_invalid_path(file_path: &Path) -> PathBuf {
    /// This function will return a [`PathBuf`] pointing to a non-existing file. \
    /// See the [`get_invalid_file`] functions documentation for more information on how the returned file path gets called.
    fn get_invalid_name(file_name: &str) -> PathBuf {
        let mut invalid_file_name;
        for i in 0.. {
            if i == 0 {
                invalid_file_name = CONFIG_DIR.join(format!("invalid_{file_name}.toml"));
            } else {
                invalid_file_name = CONFIG_DIR.join(format!("invalid_{file_name}({i}).toml"));
            }
            if !invalid_file_name.exists() {
                return invalid_file_name;
            }
        }
        panic!("A invalid file name should have been found after enough iterations.")
    }

    if !CONFIG_DIR.exists() {
        fs::create_dir_all(CONFIG_DIR.as_path())
            .await
            .unwrap_or_else(|error| {
                panic!(
                    "An error occurred while trying to create a folder at '{}'. Error: {error}",
                    CONFIG_DIR.display()
                )
            });
    }

    if file_path == CONFIG_FILE.as_path() {
        get_invalid_name("config")
    } else if file_path == MCSERVER_TYPES_FILE.as_path() {
        get_invalid_name("server_types")
    } else {
        panic!("The given static's file should not be renamed to an 'invalid file'.")
    }
}
/// This function will generate the [`struct@CONFIG_DIR`] if it does not exist and return a [`PathBuf`] pointing to a non-existing file located at:
///     1. '[`struct@CONFIG_DIR`]/invalid_`{file_name}`.toml', in case no other invalid file could be found.
///     2. '[`struct@CONFIG_DIR`]/invalid_`{file_name}`(`{counter starting at 1}`).toml', in case other invalid files could be found.
///
/// Note: `file_name` would be, for instance, for the static [`struct@SERVER_LIST_FILE`], `server_list`. \
/// \
/// # Panics
///
/// This function will panic in case the given static's file should not be renamed to an 'invalid file'.
pub async fn get_example_path(file_path: &Path) -> PathBuf {
    if !CONFIG_DIR.exists() {
        fs::create_dir_all(CONFIG_DIR.as_path())
            .await
            .unwrap_or_else(|error| {
                panic!(
                    "An error occurred while trying to create a folder at '{}'. Error: {error}",
                    CONFIG_DIR.display()
                )
            });
    }

    get_example_content(file_path).0
}
